# Член-функции. Конструктори и деструктор. Модификатори за достъп. Капсулация.

## Член-функции.
Член-функциите са функции, които работят с член-данните на обекта от дадена структура.
 ```c++
struct Point
{
	int x;
	int y;
};

bool IsInFirstQuadrant(const Point& p)
{
	return p.x >= 0 && p.y >= 0;
}

int main()
{
	Point p1 = {3, 4};
	Point p2 = {-9, 8};
	std::cout << IsInFirstQuadrant(p1) << std::endl;
	std::cout << IsInFirstQuadrant(p2) << std::endl;
}
 ```
 
Може функцията да бъде член-функция:
 ```c++
struct Point
{
	int x, y;

	bool IsInFirstQuadrant() const
	{
		return x >= 0 && y >= 0;
	}
	
};

int main()
{
	Point p1 = {3, 4};
	Point p2 = {-9, 8};
	std::cout << p1.IsInFirstQuadrant() << std::endl;
	std::cout << p2.IsInFirstQuadrant() << std::endl;
}
 ```
#  
**Член-функциите**:
 - Работят с член-данните на класа.
 -  Извикват се с обект на класа
 - Компилаторът преобразува всяка **член-функция** на дадена структура в
   обикновена функция с уникално име и един допълнителен параметър
   – **указател към обекта**.

**Константни член-функции**:

 - Не променят член-данните на структурата.
 -  Оказва се чрез записването на ключовата  дума **const** в декларацията и в края на заглавието в дефиницията им
 -  Могат да се извикват от константни обекти.

## Конструктори и деструктор.

**Жизнен цикъл на обект**:
 - Създаване на обект в даден scope – заделя се памет и член-данните се инициализират.
 - Достига се до края на скоупа(област).
 - Обектът и паметта, която е асоциирана с него се разрушава.

**Конструктор**:
 - Извиква се веднъж - при създаването на обекта.
 - Не се оказва експлицитно тип на връщане (връща констатна референция).
 - Има същото име като класа.
 
 **Деструктор**:
 - Извиква се веднъж - при изтриването на обекта.
 - Не се оказва експлицитно тип на връщане.
 - Има същото име като класа със символа '~' в началото.

 ```c++
#include <iostream>

struct Test 
{
  Test()
  {
  	std::cout << "Object is created" << std::endl;
  }
  
 ~Test()
  {
  	std::cout << "Object is destroyed" << std::endl;
  }

  int a, b;
};

int main()
{
	{
		Test t; // Object is created 
			{
				Test t2; // Object is created 
			} // Object is destroyed (t2)

	} //Object is destroyed (t)
}
 ```
 ## Капсулация (encapsulation).
Понякога искаме потребителите да **нямат достъп до всички член-данни и методи на даден клас**.
Това е така, защото тяхната промяна може да доведе до **неочаквано поведение** на нашата програма. Принципът за **капсулация** ни помага като позволява да определим кои методи и атрибути може да използват потребителите на нашия клас.

 **Модификатор за достъп**:
 
| Модификатор за достъп: | Достъп:                         |
|------------------------|---------------------------------|
| private                | В текущия клас.                 |
| protected              | В текущия клас и *наследниците. |
| public                 | За всеки                        |

**Пример за get-ъри и set-ъри**
```c++
#include <iostream>

struct Student 
{
private:
	int grade;
	int age;
public:
	Student(int grade, int age)
	{
		setGrade(grade);
		setAge(age);
	}

	int getGrade() const
	{
		return grade;
	}

	int getAge() const
	{
		return age;
	}

	void setGrade(int grade)
	{
		if(grade >= 2 && grade <= 6) {
			this->grade = grade;
		}
	}

	int setAge(int age) 
	{
		if(age >= 0) {
			this->age = age;
		}
	}
};

int main()
{
	{
		Test t; // Object is created 
		{
			Test t2; // Object is created 
		} // Object is destroyed (t2)

	} //Object is destroyed (t)
}
```

## Задачи

**Задача 1:**
Реализирайте клас/структура интервал, който представлява интервал  [a,b]  (задължително а <= b) от реалната права. Нашият интервал ще бъде дискретен - началото и краят му ще бъдат цели числа и ще разглеждаме само точки, които са цели числа. Релизирайте следният интерфейс:

 - Подразбиращ се контруктор, който създава интервала **[0,0]**.
 - Конструктор, който приема двата параметъра. Ако a<=b, то създава интервала **[a,b]**. В противен случай, създава **[0,0]**.
 - Член-функция, която връща **дължината на интервала**.
 - Член-функция, която приема число и проверява **дали е част от интервала**.
 - Член-функция, която връща **броя на простите числа** в интервала.
 - Член-функция, която връща **броя на числата в интервала**, които са палиндорми.
 - Член-функция, която връща **броя на числата, които нямат повтарящи цифри**.
 - Член-функция, която връща дали началото и края на интервала са **степени на 2-ката**. ([2,16] - истина) 
 - Член-функция, която приема интервал и връща **сечението на текущия интервал с подадения**.  (Сечението на [1, 5]  [3, 7]  e [3, 5]).
 - Член-функция, която приема интервал и връща дали подадения (като параметър) интервал е **подинтервал на текущия**(обектът, от който се извиква функцията).

  **Пример за работа с класа:**
 ```c++

int main()
{
     Interval t1(3,10); // [3, 10]
     Interval t2(4,14); // [4, 14]
     Interval t3; // [0, 0]

     Interval result = t1.intersect(t2); // [4, 10]
     
     t2.isSuperInterval(result); //true
     
     result.calcPrimeNumbersInTheInterval() // 2 (only 5 and 7)
}
 ```
