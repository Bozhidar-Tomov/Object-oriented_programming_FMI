## Статично и динамично свързване. Virtual functions(Виртуални функции)

```c++
#include <iostream>

struct A { 
    void f() const  {
		std::cout << "A::f()" << std::endl;
    }	
};

struct B : A {
    void f() const {
		std::cout << "B::f()" << std::endl;
    }	
};

void func(const A& obj) {
     obj.f();
}	

int main() {
	B* bPtr = new B();
	A* aPtr = bPtr;
	
	func(*aPtr); // A::f()
	func(*bPtr); // A::f()
}
```

- **Статично** свързване(Static binding/Early binding) - изборът на функцията, която трябва да се изпълни става **по време на компилация(Compile time)**
- **Динамично** свързване(Dynamic binding/Late binding) – изборът на функцията, която трябва да се изпълни става **по време на изпълнение на програмата(Run time)**.

```c++
#include <iostream>

struct A {
    virtual void f() const {
		std::cout << "A::f()" << std::endl;
    }	
};

struct B : public A {
    void f() const override {
       std::cout << "B::f()" << std::endl;
    }	
};

int main() {
	А* ptrs[2];
	ptrs[0] = new A();
	ptrs[1] = new B();
	
	ptrs[0]->f(); // A::f()
	ptrs[1]->f(); // B::f()
}
 ```
**Виртуална функция** - член-функция, която е декларирана в основен клас(Base class) и е предефинирана от производен клас(Derived class). <br />
Гарантират, че правилната функция ще се извика за даден обект, независимо от типа reference/pointer(типа препратка), <br />
използван за извикване на функцията. Те се използват главно за постигане на Runtime polymorphism. <br />

### Правила за виртуални функции
  - **не могат** да бъдат static.
  - Прототипът на виртуалните функции трябва да бъде един и същ както в базовия, така и в производния клас.
  - Винаги се дефинират в базовия клас, като се предефинират в производния. Не е задължително производния клас да заменя или предефинира виртуалната функция, в такъв случай се използва версията на базовия клас.
  - Достъпът до виртуалните функции трябва да се осъществява използвайки reference/pointer към базовия клас, за да се осъществи Runtime polymorphism.
  - **Класът може да има виртуален деструктор, но не може да има виртуален конструктор.**

### Specifiers - override & final
- override указва, че дадена функция презаписва функция от базовия клас. Ако в базовия клас няма такава функция, то кодът няма да се компилира.
- final указва, че дадена функция не може да се презависва надолу по йерархията или че даден клас не може да се наследява.

### Virtual pointer(vPtr) | Virtual table(vTable)

TBA

## Полиморфизъм
 
TBA

## Абстрактен клас

TBA 

